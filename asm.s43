;MSP LCD Demo

;Just like we include "msp430.h" I *assume* we can do something like "include "drawutils.s43"" on the main cosa de esta and be able to do it.

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

         ORG     0FFFEh
         DC16    init                    ; set reset vector to 'init' label
         
         ORG     01C00h                ; Start of RAM
         
;Digits      0    1     2     3     4     5     6     7     8     9      +     -     *     /
DigitH   db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0x03, 0x03, 0x00, 0x00
DigitL   db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0xFA, 0x28

LCDADD   db     0xa29, 0xa25, 0xa23, 0xA32, 0xA2E, 0xA27
;LCDADDL db     0xa2a, 0xa26, 0xa24, 0xA33, 0xA2F, 0xA28

         RSEG    CSTACK                  ; pre-declaration of segment
         RSEG    CODE                    ; place program in 'CODE' segment

init:    MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

      ;Enable LCD Segments 0-21; 26-43

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2
        
        
SetupP1:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for outpuu
        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        bic.b   #0x01,&P1OUT            ; Clear P1.0 and P9.7 output latch to
        bic.b   #0x80,&P9OUT            ; start with both off
        
UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w #LOCKLPM5, &PM5CTL0       ; High-impedance mode to acivade
                                        ; previously configured port settings
        ;Initialize LCD_C
        MOV.W   #0x041e,&LCDCCTL0

        ;VLCD generated internally,
        ;V2-V4 Generated internally, v5 to ground.
        ;set VLCD Voltaeg to 2.6V
        ;Enable Charge pump and select internal reference for it.

        MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL     ;Clock sync Enabled
        
        call #ClearLCD          ;Clear LCD Memory

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        MOV.B #1,R6 ;Points to first digit spot.
        MOV.W #0,R5
        mov.b #0,R7
        
nextDigitSetup:
        ;Setting up stuff for nextDigit
        mov.b   #9,R14
        mov.b   #0,R9
        mov.b   #0,R15
        mov     #0,R10
        
 Mainloop:
        Call    #ClearReg
        Call    #StartDisplay
        Call    #EnterInt
        mov     R9,R8
        Call    #nextSign
        Call    #Delay
        Call    #StartDisplay
        mov     #0,R10
        mov.b   #0,R15                    ;Clears R15 back to 0 to keep track of inputs
        Call    #EnterInt
        Call    #Operate
        Call    #ClearLCD
        mov.b   #0,R15                    ;Clears R15 back to 0 to keep track of inputs
        mov     R10,R5
        Call    #DrawResult
        Call    #isNegative
        mov     #0,R10
        Call    #HoldResult
        jmp     Mainloop
        

DrawResult:
        Mov     #1,R6
        Mov     #0,R8
        cmp     #0,R12
        jeq     DrawInt
        Call    #Drawing100
        Call    #Drawing10
        Call    #Drawing1
        Mov     R10,R12
        Call    #Drawing100
        Call    #Drawing10
        Call    #Drawing1
        jmp     fin
        
    
Drawing100:
        cmp     #2,R6
        jge     DrawSecSeg100
        cmp     #100,R12
        jge     reduce100
        jmp     fin
        
        
DrawSecSeg100:
        cmp     #100,R12
        jge     reduce100
        Mov     R8,R5
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin
        
        
Drawing10:
        cmp     #10,R12
        jge     reduce10
        cmp     #2,R6
        jge     Draw10
        jmp     fin
        
    
Drawing1:
        cmp     #1,R12
        jge     reduce1
        cmp     #2,R6
        jge     Draw1
        jmp     fin
        
        
reduce100:
        Inc     R8
        sub     #100,R12
        cmp     #100,R12
        jlo     Draw100
        jmp     reduce100
        
Draw100:
        Mov     R8,R5
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin


reduce10:
        Inc     R8
        sub     #10,R12
        cmp     #10,R12
        jlo     Draw10
        jmp     reduce10
        
        
Draw10:
        Mov     R8,R5
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin


reduce1:
        Inc     R8
        sub     #1,R12
        cmp     #1,R12
        jlo     Draw1
        jmp     reduce1
        
        
Draw1:
        Mov     R8,R5
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin
        
        
isNegative:
        cmp     #1,R8
        jeq    DrawNegative
        jmp     fin
        
    
DrawNegative:
  BIS.B #0x04,&0xA2A                    ;Draw Negative
  jmp   fin
        
        
StartDisplay:
        Call #DrawDigit1
        jmp  fin
        
        
EnterInt:
        mov.b   &P1IN,R13 
	and.b   #00000110B,R13
        cmp.b   #00000100B,R13
        jeq     nextDigit
        cmp.b   #00000010B,R13
        jeq     secondSetup
	jmp EnterInt
        
        
        
nextDigit:

        INC     R5
        cmp     #10,R5
        jeq     EqualTo10
        Call    #SegDraw

        Call    #Delay
        Mov     #0,R13
        cmp     #10000,R12
        jnz     EnterInt
        
        inc.b   R6
        cmp     #7,R6             ;Loop until R6 (Pos) is 7
        MOV.B   #0,R5
        jnz     EnterInt
        
        jmp     fin
        
        
 EqualTo10:
        Mov     #0,R5
        Call    #SegDraw
        Call    #Delay
        jmp     EnterInt


 secondSetup:
        Call    #SaveInput
        Call    #Delay
        inc     R15
        cmp     #3,R15
        jeq     termine
        Mov.w   #0,R13
        Mov.w   #0,R5
        Call    #SegDraw
        jmp     EnterInt
        
        
termine:
        Mov     R10,R9
        MOV.W   #0,R5
        CALL    #ClearLCD
        jmp     fin
        
        
SegDraw:
        cmp     #0,R15
        jeq     DrawDigit1
        cmp     #1,R15
        jeq     DrawDigit2
        cmp     #2,R15
        jeq     DrawDigit3
        
        
SaveInput:
        Mov     R5,R13
        cmp     #0,R15
        jeq     Save1st
        cmp     #1,R15
        jeq     Save2nd
        cmp     #2,R15
        jeq     Save3rd
        
Save1st:
        cmp     #0,R13
        jne     still1
        ;add     R13,R10
        jmp     fin
        
 still1:
        add     #100,R10
        dec     R13
        jmp     Save1st
        
 Save2nd:
        cmp     #0,R13
        jne     still2
        ;add     R13,R10
        jmp     fin
        
 still2:
        add     #10,R10
        dec     R13
        jmp     Save2nd
        
 Save3rd:
        cmp     #0,R13
        jne     still3
        ;add     R13,R10
        jmp     fin
        
 still3:
        add     #1,R10
        dec     R13
        jmp     Save3rd
        
        
EnterSign:
        mov.b   &P1IN,R13 
	and.b   #00000110B,R13
        cmp.b   #00000100B,R13
        jeq     nextSign
        cmp.b   #00000010B,R13
        jeq     fin
	jmp     EnterSign
        
        
 nextSign:
        Call    #Delay
        cmp     #4,R7
        jge     strtAgain                       ;Starts the sign cycle again after it is >=4
        call    #ClearLCD
        call    #DrawSign
        Mov     R7,R4                           ;Saves operation identifier on R4
        inc.b   R7
        jmp     EnterSign
        
        
strtAgain:
        mov.b   #0,R7
        jmp     nextSign
        
        
Operate:
        Mov     #0,R10
        Mov     #0,R12
        cmp     #0,R4
        jeq     sum
        cmp     #1,R4
        jeq     substraction
        cmp     #2,R4
        jeq     mult
        cmp     #3,R4
        jeq     divi
        
        
sum:
        add     R8,R9
        Mov     R9,R10
        jmp     fin
        
        
substraction:
        cmp     R8,R9
        jeq     equalToZero
        cmp     R8,R9
        jge     swap
        sub     R9,R8
        Mov     R8,R10
        Mov     #0,R8
        jmp     fin
        
        
equalToZero:
        Mov     #0,R10
        jmp     fin
        
        
swap:
        Mov     R9,R10
        Mov     R8,R9
        Mov     R10,R8
        sub     R9,R8
        Mov     R8,R10
        Mov     #1,R8
        jmp     fin
        
        
mult:
        cmp     #1000,R10
        jge     nextRegister
        cmp     #0,R9
        jeq     fin
        cmp     #0,R8
        jeq     fin
        dec     R9
        add     R8,R10
        jmp     mult
        

MoveValues:
        Inc     R12
        sub     #1000,R10
        jmp     mult
        
        
nextRegister:
        Inc     R12
        sub     #1000,R10
        jmp     mult
          
        
divi:     
        cmp   #0,R9
        jeq   fin
        cmp   #0,R8
        jeq   fin
        sub   R9,R8
        jn    fin
        add   #1,R10
        jmp   divi
        
        
HoldResult:
        mov.b   &P1IN,R13 
	and.b   #00000110B,R13
        cmp.b   #00000010B,R13
        jeq     ClearReg         ;When right clicked resets everything for next operation
	jmp     HoldResult
        
ClearReg:       ;Clears register for next run
        Call    #Delay
        
        mov     #0,R4
        mov     #0,R5
        
        mov     #1,R6           ;Tells us which segment we will use and we always at the very least use the 1st

        mov     #0,R7
        mov     #0,R8
        mov     #0,R9
        mov     #0,R10
        mov     #0,R11
        mov     #0,R12
        mov     #0,R13
        mov     #0,R14
        mov     #0,R15
        Call    #ClearLCD
        
        jmp     fin
              
        
Delay:
        MOV     #50000,R13
        
Next:
        dec     R13
        jnz     Next
        jmp     fin
        
;Objective: Draw an arithmetic sign (+, -, *, or /) determined by R7 (0, 1, 2, or 3) at segment 1-6 on the LCD, determined by R6
;Preconditions: Arithmetic sign must be on R7 (0-3), and Segment must be on R6 (1-6)
;Postconditions: Arithmetic sign is drawn on the LCD. Nothing is changed.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawSign:
        push.w  R7 ;Save R7
        push.w  R5 ;Save R5
        add     #10,R7 ;Add 10 so 0->10, 1->11, 2->12 etc.
        mov.b   R7,R5 ;Move R7 to R5 so that we can draw R7
        call    #DrawDigit ;Take us straight to the part of Drawint where we decide where to draw R5 which should be a digit but if it isn't it goes further in the array to find the signs.
        pop.w   R5 ;Return R5
        pop.w   R7 ;Return R7
        ret ;And let's get the hell out of here.
    

;Objective: Draws a whole int (-10000 not included to 10000 not included) to the LCD starting at position 1-6 on the LCD
;Preconditions: Whole int must be on R5, and starting position must be on R6
;Postconditions: Number is drawn on the LCD. Nothing is changed.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntSafe:
DrawInt:
       push.w   R6
       push.w   R11
       push.w   R5
    
    ;CHECK IF NEGATIVE AND IF NEGATIVE FLIP
      cmp.w     R5,0
      jlo       DrawIntFlipR5
DrawIntFlipR5Cont:    
    
      call      #DrawIntDirect
      pop.w     R5
      pop.w     R11
      pop.w     R6
    
    ;CHECK IF NEGATIVE AGAIN AND IF NEGATIVE DRAW NEGATIVE SIGN.
      cmp.w     R5,0
      jlo       DrawIntDrawNegative ;no need for a cont tag since we can use the return in DrawIntDrawNegative to return.
      ret

;Objective: Convert R5 from a negative value to a positive value
;Preconditions: value to bit invert must be on R5
;Postconditions: R5's binary value is returned inverted, and incremented by 1. (IE 0xFFFF --> 0x0001)
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntFlipR5:
      inv       R5
      inc.w     R5
      jmp       DrawIntFlipR5Cont
  
;Objective: Draws the negative sign on the first position
;Preconditions: None
;Postconditions: Negative sign is drawn.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDrawNegative:
      BIS.B     #0x04,&0xA2A ;Draw Negative
      ret ;return


;Objective: Draws an unsigned (assumed positive) integer at position R6 WITHOUT ensuring that R5, R6, and R11 are preserved. Should only be used internally by DrawInt
;Preconditions: Integerger value must be at R5 and must be positive unsigned. Position value must be at R6 and must be 1-6
;Postconditions: int at R5 is drawn at position R6 on the LCD. Registers may have been modified.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDirect:
      
      cmp.w     #7,R6
      jge       DrawIntOver10000 ;If R6 is over 6 (IE >=7) then oops that's beyond the screen RETURN
      
      cmp.w     #10000,R5
      jge       DrawIntOver10000 ;If it's over 10,000 return we aren't drawing that

      mov.b     #0,R11 ;reset R11 becuase we're going to use it to *count*

      cmp.w     #1000,R5
      jge       DrawIntOver1000 ;If it's over 1000

      cmp.w     #100,R5
      jge       DrawIntOver100 ;If it's over 100

      cmp.w     #10,R5
      jge       DrawIntOver10 ;If it's over 10
      ;Here we continue on to DrawDigit. This is intentional

;Objective: Draws digit or sign in R5 (0-13) at position R6 (1-6) on the LCD. 
;Preconditions: Value to draw must be on R5, and position must be on R6
;Postconditions: R5's value is drawn to R6 on the LCD. Nothing is changed
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawDigit:

      ;Draw the specific digit
      cmp.b     #6,R6
      jeq       DrawDigit6
      
      cmp.b     #5,R6
      jeq       DrawDigit5
      
      cmp.b     #4,R6
      jeq       DrawDigit4
      
      cmp.b     #3,R6
      jeq       DrawDigit3
      
      cmp.b     #2,R6
      jeq       DrawDigit2
      
      cmp.b     #1,R6
      jeq       DrawDigit1

      ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(The following subroutines DrawDigit1 - DrawDigit6) can be described using the following comment)
;Objectives: Draws digit or sign in R5 (0-13) at position N on the LCD (Where N represents the number at the end of DrawDigitN). 
;Preconditions: Value to draw must be on R5
;Postconditions: R5's value is drawn to N on the LCD. Nothing is changed
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawDigit1:
      MOV.B     #9,R11 ;Reuse R11 because why not
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit2:
      MOV.B     #5,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit3:
      MOV.B     #3,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit4:
      MOV.B     #2,R11
      MOV.B     DigitH(R5),0xA30(R11)
      MOV.B     DigitL(R5),0xA30+1(R11)
ret

DrawDigit5:
      MOV.B     #14,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit6:
      MOV.B     #7,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;DRAWINT INTERNAL SUBROUTINES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;The following subroutines are meant to be *internal* and should not be used outside of DrawInt

;Objectives: Return call for values over 10000 or R6>7
;Preconditions: (none)
;Postconditions: Returns
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver10000:
      ret ;Return because we won't need to do that. ahahahaha

;Objectives: Handles the process of drawing an integer over 1000.
;Preconditions: Value to draw must be on R5 and must be at least over 1000. R11 must already be 0
;Postconditions: R5's Thousands place is drawn to the LCD at position R6. R5's thousands place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawIntOver100
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver1000:
      sub.w     #1000,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 1000 
      cmp       #1000,R5
      jge       DrawIntOver1000  ;until its no longer >=1000

     ;Draw and reset R11
      call      #DrawIntDrawR11
      
      inc.b     R6 ;Increment R6

      jmp       DrawIntOver100;Continue on to DrawIntOver100

;Objectives: Handles the process of drawing an integer over 100.
;Preconditions: Value to draw must be on R5. R11 must already be 0
;Postconditions: R5's Hundreds place is drawn to the LCD at position R6. R5's Hundreds place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawIntOver10
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver100:
      
      cmp       #100,R5
      jlo       DrawIntUnder100Already  ;Check if it's bellow 100. Otherwise, 
      
      sub.w     #100,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 100
      jmp       DrawIntOver100  ;until its no longer >=100
      
      ;Internal jump point to indicate we're already under 100.
      DrawIntUnder100Already:
      
      ;Draw and reset R11
      call      #DrawIntDrawR11
      inc.b     R6 ;Increment R6      

      jmp       DrawIntOver10 ;Continue on to DrawIntOver10

;Objectives: Handles the process of drawing an integer over 10.
;Preconditions: Value to draw must be on R5. R11 must already be 0
;Postconditions: R5's tens place is drawn to the LCD at position R6. R5's tens place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawDigit
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver10:
      cmp       #10,R5
      jlo       DrawIntUnder10Already  ;Check if we're already under 10. Otherwise...

      sub.w     #10,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 1000 
      jmp       DrawIntOver10  ;until its no longer >=10

;Internal jump point to indicate we're already under 10
DrawIntUnder10Already:

      ;Draw and reset
      call      #DrawIntDrawR11
      inc.b     R6 ;Increment R6      
      
      ;Jump to DrawDigit. It has a return so we'll return once we draw the last digit
      jmp       DrawDigit


;Objectives: Handles the process of drawing a digit that's in R11 and clearing R11. INTERNAL USE ONLY FOR DrawIntOver(N) SUBROUTINES.
;Preconditions: Value to draw must be in R11 and must be between 0-9. Position to draw R11 must be on R6
;Postconditions: R11 is drawn to position R6, and is then set to 0. R5 is preserved.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDrawR11:
      push.w    R5 ;Save R5
      mov.w     R11,R5 ;Move R11 to R5
      call      #DrawDigit ;Draw R11 (now in R5)
      pop.w     R5 ;Return R5
      mov.b     #0,R11 ;Reset R11 for the next subroutine.
      ret



;Objectives: Clears the LCD
;Preconditions: LCD is already initialized
;Postconditions: LCD is cleared
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
ClearLCD:
      MOV.W   #2,&LCDCMEMCTL
      BIS.W   #1,&LCDCCTL0
      ret
        
fin:    RET
        
TheEnd: JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
