;MSP LCD Demo

;Just like we include "msp430.h" I *assume* we can do something like "include "drawutils.s43"" on the main cosa de esta and be able to do it.

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module

         ORG     0FFFEh
         DC16    init                    ; set reset vector to 'init' label
         
         ORG     01C00h                ; Start of RAM
         
;Digits      0    1     2     3     4     5     6     7     8     9      +     -     *     /
DigitH   db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7, 0x03, 0x03, 0x00, 0x00
DigitL   db 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0xFA, 0x28

LCDADD   db     0xa29, 0xa25, 0xa23, 0xA32, 0xA2E, 0xA27
;LCDADDL db     0xa2a, 0xa26, 0xa24, 0xA33, 0xA2F, 0xA28

         RSEG    CSTACK                  ; pre-declaration of segment
         RSEG    CODE                    ; place program in 'CODE' segment

init:    MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

      ;Enable LCD Segments 0-21; 26-43

        MOV.W   #0xffff,&LCDCPCTL0
        MOV.W   #0xfc3f,&LCDCPCTL1
        MOV.W   #0x0fff,&LCDCPCTL2
        
        
SetupP1:
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1
        
        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for outpuu
        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B,&P1REN       ; Activate P1.1 and P1.2 programable
                                        ; pull-up/pull-down resistors
        bis.b   #00000110B,&P1OUT       ; Set resistors for P1.1 and P1.2 as
                                        ; as pull-down
        bic.b   #0x01,&P1OUT            ; Clear P1.0 and P9.7 output latch to
        bic.b   #0x80,&P9OUT            ; start with both off
        
UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w #LOCKLPM5, &PM5CTL0       ; High-impedance mode to acivade
                                        ; previously configured port settings
        ;Initialize LCD_C
        MOV.W   #0x041e,&LCDCCTL0

        ;VLCD generated internally,
        ;V2-V4 Generated internally, v5 to ground.
        ;set VLCD Voltaeg to 2.6V
        ;Enable Charge pump and select internal reference for it.

        MOV.W   #0x0208,&LCDCVCTL

        MOV.W   #0x8000,&LCDCCPCTL     ;Clock sync Enabled
        
        call #ClearLCD          ;Clear LCD Memory

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        MOV.B #1,R6 ;Points to first digit spot.
        MOV.W #0,R5
        mov.b #0,R7
        
nextDigitSetup:
        ;Setting up stuff for nextDigit
        mov.b   #9,R14
        mov.b   #0,R9
        mov.b   #0,R15
        mov     #0,R10
        
 Mainloop:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Call    #start                     ;Starts calculator which when it finishes an operation and right clicked when displaying result, it loops back to Mainloop
        jmp     TheEnd                     ;Ends program in case of edge case
        
        
start:
        Call    #ClearReg                  ;Clears registes to start gattering data and setting the fields for the calculator process

        Call    #StartDisplay              ;Displays the first segment with a 0 to start the enterInt process
        Call    #EnterInt                  ;Receives input pertaining the first integer for the operation
        mov     R9,R8                      ;Since the input integer is saved in R9, here we move it to R8 which is the register that will hold the first integer for the operation.
        
        Call    #nextSign                  ;Starts the process for picking which operation will be carried out. (+,-,*,/)
        Call    #Delay                     ;Gives some time for the data to be processed correctly

        Call    #StartDisplay              ;Displays the first segment with a 0 to start the enterInt process
        mov     #0,R10                     ;Clears R10, since this is the register supposed to hold the result values. This is done in case of an edge case. This way we avoid issues that may occur 
        mov.b   #0,R15                     ;Clears R15 back to 0 to keep track of inputs
        Call    #EnterInt                  ;Receives input pertaining the second integer for the operation

        Call    #Operate                   ;Carries out the operation chosen with the use of the 2 integers that were provided. The result of the operation is saved on R10. R8-> first integer, R9-> second integer, R10-> Result. 

        Call    #ClearLCD                  ;Clears the display to prepare for displaying the result for the operation.
        mov.b   #0,R15                     ;Clears R15 back to 0 to keep track of inputs.
        mov     R10,R5                     ;Moves result to R5. The program displays the values inside R5 when the draw functions are called or jmped to.
        Call    #DrawResult                ;Draws the result of the operations on the display
        Call    #isNegative                ;If the result was negative, this will add the negative sign to the display.

        mov     #0,R10                     ;Resets R10 -> result back to 0, in preparation for the next run of the calculator.
        Call    #HoldResult                ;Displays the result until the lunchpad is rightclicked to start the process again.
        jmp     Mainloop                   ;When right clicked the program will jmp to Mainloop and carry out the program again
        
                                           ;----------------------------------------              Jomar Santos           ---------------------------------------------------------


DrawResult:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     #1,R6                      ;Moves 1 to R6 which signals the segment in which we will be writing.
        Mov     #0,R8                      ;R8 will be used as a counter and for said reason we move a 0 to it.
        cmp     #0,R12                     ;R12 holds half of the result for multiplications when this exceeds 1000. This is done to be able to display results up to 999,999.
        jeq     DrawInt                    ;If equal then the drawing on the display will be carried out normally as done with division, subtraction and sum.

        Call    #Drawing100                ;If previous condition is not met, we start breaking down the result in 100, 10 and 1, displaying first the half stored in R12.
        Call    #Drawing10
        Call    #Drawing1
        
        Mov     R10,R12                    ;We move the other half of the result in R10, to R12, to carry out the previous process and display the other half.
        Call    #Drawing100
        Call    #Drawing10
        Call    #Drawing1
        
        jmp     fin
                                          ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
    
Drawing100:
        cmp     #2,R6                     ;Compare in which segment we are drawing at the moment.
        jge     DrawSecSeg100             ;If we are not on the 1st segment (R6 >= 2) then we jmp to DrawSecSeg100, to avoid the program from not writing 0's when they need to be drawn.

        cmp     #100,R12                  ;Compare that R12 is greater than 100.
        jge     reduce100                 ;If R12 is greater than 100, we proceed to writing the centecimal position on the register.

        jmp     fin                       ;If no condition were met we jump to the next number in the integer. In this case we would jump to the decimals, or multiples of 10.
        
                                          ;----------------------------------------              Jomar Santos           ---------------------------------------------------------

DrawSecSeg100:                            ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #100,R12                  
        jge     reduce100                 ;Compare if 12 is greater of equal to 100. If so, we reduce 100 from it and increase R8 by 1 in the reduce100 function.

        Mov     R8,R5                     ;If the condition is not met then we move R8 to R5, to display in DrawIntDirect.
        Call    #DrawIntDirect
        
        Inc     R6                        ;We increse R6 by one to point to the next segment in which we will be writing.
        Mov     #0,R8                     ;We clear R8, since this is the counter. This way we can use it for the next positions.
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Drawing10:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #10,R12                  ;Same process as with the Drawing100 function but with 10 instead.
        jge     reduce10                
        cmp     #2,R6
        jge     Draw10
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
    
Drawing1:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #1,R12                   ;Same process as with the Drawing100 function but with 1 instead.
        jge     reduce1
        cmp     #2,R6
        jge     Draw1
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
reduce100:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Inc     R8                       ;Since the condition to enter the function was met we, increase R8 bby one. This will keep track of the number of times we reduce the number by 100 and is the number which will be displayed.
        sub     #100,R12                 ;Subtract 100 from the half of the result stored in R12.

        cmp     #100,R12                 
        jlo     Draw100                  ;If R12 is lower than 100 we proceed to draw the number stored in R8. Example if we had 900, we subtract 100, 9 times and this is stored in R8 which is what we want to display.
        jmp     reduce100                ;If the number is not lower than 100, then we keep reducing until it is.
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Draw100:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     R8,R5                    ;We move R8 to R5 since we display values inside R5.
        Call    #DrawIntDirect           ;We write what's stored in R5 to the display

        Inc     R6                       ;We increase R6 by one since this points to the segment in which we want to write on next.
        Mov     #0,R8                    ;We reset R8 (our counter) by passing it a 0, to prepare use in the next stage.
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------

reduce10:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Inc     R8                       ;Same process as with the reduce100 function but with 10 instead.
        sub     #10,R12
        cmp     #10,R12
        jlo     Draw10
        jmp     reduce10
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Draw10:                                  ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     R8,R5                    ;Same process as with the Draw100 function but with 10 instead.
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------

reduce1:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Inc     R8                       ;Same process as with the reduce100 function but with 1 instead.
        sub     #1,R12
        cmp     #1,R12
        jlo     Draw1
        jmp     reduce1
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Draw1:                                   ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     R8,R5                    ;Same process as with the Draw100 function but with 1 instead.
        Call    #DrawIntDirect
        Inc     R6
        Mov     #0,R8
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
isNegative:                              ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #1,R9                    ;In subtraction, if the result is negative, then a 1 will be stored in R9.
        jeq    DrawNegative              ;If the condition is met, then the result is negative and we jmp to DrawNegative.
        jmp     fin                      
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
    
DrawNegative:                            ;-----------------------------------  Jomar Santos referencing Ignacio's code  --------------------------------------------------------
  BIS.B #0x04,&0xA2A                     ;Draw Negative
  jmp   fin
                                         ;-----------------------------------  Jomar Santos referencing Ignacio's code  --------------------------------------------------------
        
StartDisplay:                            ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Call #DrawDigit1                 ;Calls funtion to write 0 on the first segment to initialize EnterInt process.
        jmp  fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
EnterInt:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        mov.b   &P1IN,R13                ;In this whole funtion we loop and listens to when we have a left or right click. If the conditions are met, we jump to respective funtions.
	and.b   #00000110B,R13
        cmp.b   #00000100B,R13
        jeq     nextDigit
        cmp.b   #00000010B,R13
        jeq     secondSetup
	jmp EnterInt
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
        
nextDigit:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        INC     R5                       ;Increase R5 by one to display the next number option.

        cmp     #10,R5                   
        jeq     EqualTo10                ;If R5 is equal to 10 we reset it to 0.
        Call    #SegDraw                 ;We draw the number in R5, which is the next option.

        Call    #Delay                   ;We delay to accurately take in the data the user wants stored.
        Mov     #0,R13                   ;Reset R13 back to 0.
        jmp     EnterInt                 ;jmp back to listening for left or right input.
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 EqualTo10:                              ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     #0,R5                    ;Resets R5 back to 0.
        Call    #SegDraw                 ;Displays the 0 to the launchpad.
        Call    #Delay                   ;We delay to accuratelly take in the data the user wants to store
        jmp     EnterInt                 ;jmp back to listening for left or right input.
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------

 secondSetup:                            ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Call    #SaveInput               ;Stores the input the user provided.
        Call    #Delay
        inc     R15                      ;Increase R15 since this will keep track for the segments left to chose integers for to complete the integer.
        cmp     #3,R15
        jeq     termine                  ;If R15 is equal to 3 then we finished picking the integer.
        Mov.w   #0,R13                   ;Resets R13, to listen for left and right input properly.
        Mov.w   #0,R5                    ;Resets R5 back to 0.
        Call    #SegDraw                 ;Displays the 0 on the launchpad.
        jmp     EnterInt                 ;jmp back to listening for left or right input.
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
termine:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     R10,R9                   ;Move the stored integer value to R9.
        MOV.W   #0,R5                    ;Resets R5 to 0.
        CALL    #ClearLCD 
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
SegDraw:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #0,R15                   ;Depending on the position stored on R15, we draw the integer on the corresponding segment from the 1st to the 3rd.
        jeq     DrawDigit1
        cmp     #1,R15
        jeq     DrawDigit2
        cmp     #2,R15
        jeq     DrawDigit3
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
SaveInput:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Mov     R5,R13                   ;This funtion saves the values inside R5 in R13, to properly save the wanted value of the user on the register.
        cmp     #0,R15
        jeq     Save1st
        cmp     #1,R15
        jeq     Save2nd
        cmp     #2,R15
        jeq     Save3rd
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Save1st:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #0,R13        
        jne     still1                   ;If we are on the 1st segment and R13 is not 0 we jmp to still1. R13 is our counter for the number.
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 still1:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        add     #100,R10                 ;Since we are on the 1st segment we add 100 to R10.
        dec     R13                      ;Here we decrease our counter by 1.
        jmp     Save1st
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 Save2nd:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #0,R13                   ;Same as funtion Save1st but with the second segment
        jne     still2
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------

 still2:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        add     #10,R10                  ;Same as funtion still1 but we add 10, since we are in the second segment which are multiples of 10.
        dec     R13
        jmp     Save2nd
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 Save3rd:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        cmp     #0,R13                   ;Same as funtion Save1st but with the third segment
        jne     still3
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 still3:                                 ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        add     #1,R10                   ;Same as funtion still1 but we add 1, since we are in the third segment which are increments of one. Which I could had just used Inc instead. 
        dec     R13
        jmp     Save3rd
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
EnterSign:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        mov.b   &P1IN,R13                ;Same as the EnterInt function but when left click cycles through the operations available (+,-,*,/) and if right clicks then it jumps to the next step.
	and.b   #00000110B,R13
        cmp.b   #00000100B,R13
        jeq     nextSign
        cmp.b   #00000010B,R13
        jeq     fin
	jmp     EnterSign
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
 nextSign:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Call    #Delay
        cmp     #4,R7
        jge     strtAgain                ;If R7 is at 4 then we reset it back to 0 (+)
        call    #ClearLCD
        call    #DrawSign
        Mov     R7,R4                           
        inc.b   R7
        jmp     EnterSign
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
strtAgain:                               ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        mov.b   #0,R7                    ;Resets signs back to (+)
        jmp     nextSign
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Operate:
        Mov     #0,R10
        Mov     #0,R12
        cmp     #0,R4
        jeq     sum
        cmp     #1,R4
        jeq     substraction
        cmp     #2,R4
        jeq     mult
        cmp     #3,R4
        jeq     divi
        
        
sum:
        add     R8,R9
        Mov     R9,R10
        jmp     fin
        
        
substraction:
        cmp     R8,R9
        jeq     equalToZero
        cmp     R8,R9
        jge     swap
        sub     R9,R8
        Mov     R8,R10
        Mov     #0,R8
        jmp     fin
        
        
equalToZero:
        Mov     #0,R10
        jmp     fin
        
        
swap:
        Mov     R9,R10
        Mov     R8,R9
        Mov     R10,R8
        sub     R9,R8
        Mov     R8,R10
        Mov     #1,R9
        jmp     fin
        
        
mult:
        cmp     #1000,R10
        jge     nextRegister
        cmp     #0,R9
        jeq     fin
        cmp     #0,R8
        jeq     fin
        dec     R9
        add     R8,R10
        jmp     mult
        

MoveValues:
        Inc     R12
        sub     #1000,R10
        jmp     mult
        
        
nextRegister:
        Inc     R12
        sub     #1000,R10
        jmp     mult
          
        
divi:     
        cmp   #0,R9
        jeq   fin
        cmp   #0,R8
        jeq   fin
        sub   R9,R8
        jn    fin
        add   #1,R10
        jmp   divi
        
        
HoldResult:                              ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        mov.b   &P1IN,R13                ;Displays result until right click which starts calculator process for next operation if any.
	and.b   #00000110B,R13
        cmp.b   #00000010B,R13
        jeq     ClearReg                 ;When right clicked resets everything for next operation
	jmp     HoldResult
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
ClearReg:                                ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        Call    #Delay                   ;This funtion clears register for next run
        
        mov     #0,R4
        mov     #0,R5
        
        mov     #1,R6                    ;Tells us which segment we will use and we always at the very least use the 1st. Because this we pass a 1 to R6.

        mov     #0,R7
        mov     #0,R8
        mov     #0,R9
        mov     #0,R10
        mov     #0,R11
        mov     #0,R12
        mov     #0,R13
        mov     #0,R14
        mov     #0,R15
        Call    #ClearLCD
        
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
Delay:                                   ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        MOV     #50000,R13               ;This funtion passes a 50000 to R13 so that it funtions as a delay to accurately carry out the funtions of the calculator.
        
Next:
        dec     R13                      ;Here we loop through Next until R13 is 0.
        jnz     Next
        jmp     fin
                                         ;----------------------------------------              Jomar Santos           ---------------------------------------------------------
        
;Objective: Draw an arithmetic sign (+, -, *, or /) determined by R7 (0, 1, 2, or 3) at segment 1-6 on the LCD, determined by R6
;Preconditions: Arithmetic sign must be on R7 (0-3), and Segment must be on R6 (1-6)
;Postconditions: Arithmetic sign is drawn on the LCD. Nothing is changed.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawSign:
        push.w  R7 ;Save R7
        push.w  R5 ;Save R5
        add     #10,R7 ;Add 10 so 0->10, 1->11, 2->12 etc.
        mov.b   R7,R5 ;Move R7 to R5 so that we can draw R7
        call    #DrawDigit ;Take us straight to the part of Drawint where we decide where to draw R5 which should be a digit but if it isn't it goes further in the array to find the signs.
        pop.w   R5 ;Return R5
        pop.w   R7 ;Return R7
        ret ;And let's get the hell out of here.
    

;Objective: Draws a whole int (-10000 not included to 10000 not included) to the LCD starting at position 1-6 on the LCD
;Preconditions: Whole int must be on R5, and starting position must be on R6
;Postconditions: Number is drawn on the LCD. Nothing is changed.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntSafe:
DrawInt:
       push.w   R6
       push.w   R11
       push.w   R5
    
    ;CHECK IF NEGATIVE AND IF NEGATIVE FLIP
      cmp.w     R5,0
      jlo       DrawIntFlipR5
DrawIntFlipR5Cont:    
    
      call      #DrawIntDirect
      pop.w     R5
      pop.w     R11
      pop.w     R6
    
    ;CHECK IF NEGATIVE AGAIN AND IF NEGATIVE DRAW NEGATIVE SIGN.
      cmp.w     R5,0
      jlo       DrawIntDrawNegative ;no need for a cont tag since we can use the return in DrawIntDrawNegative to return.
      ret

;Objective: Convert R5 from a negative value to a positive value
;Preconditions: value to bit invert must be on R5
;Postconditions: R5's binary value is returned inverted, and incremented by 1. (IE 0xFFFF --> 0x0001)
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntFlipR5:
      inv       R5
      inc.w     R5
      jmp       DrawIntFlipR5Cont
  
;Objective: Draws the negative sign on the first position
;Preconditions: None
;Postconditions: Negative sign is drawn.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDrawNegative:
      BIS.B     #0x04,&0xA2A ;Draw Negative
      ret ;return


;Objective: Draws an unsigned (assumed positive) integer at position R6 WITHOUT ensuring that R5, R6, and R11 are preserved. Should only be used internally by DrawInt
;Preconditions: Integerger value must be at R5 and must be positive unsigned. Position value must be at R6 and must be 1-6
;Postconditions: int at R5 is drawn at position R6 on the LCD. Registers may have been modified.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDirect:
      
      cmp.w     #7,R6
      jge       DrawIntOver10000 ;If R6 is over 6 (IE >=7) then oops that's beyond the screen RETURN
      
      cmp.w     #10000,R5
      jge       DrawIntOver10000 ;If it's over 10,000 return we aren't drawing that

      mov.b     #0,R11 ;reset R11 becuase we're going to use it to *count*

      cmp.w     #1000,R5
      jge       DrawIntOver1000 ;If it's over 1000

      cmp.w     #100,R5
      jge       DrawIntOver100 ;If it's over 100

      cmp.w     #10,R5
      jge       DrawIntOver10 ;If it's over 10
      ;Here we continue on to DrawDigit. This is intentional

;Objective: Draws digit or sign in R5 (0-13) at position R6 (1-6) on the LCD. 
;Preconditions: Value to draw must be on R5, and position must be on R6
;Postconditions: R5's value is drawn to R6 on the LCD. Nothing is changed
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawDigit:

      ;Draw the specific digit
      cmp.b     #6,R6
      jeq       DrawDigit6
      
      cmp.b     #5,R6
      jeq       DrawDigit5
      
      cmp.b     #4,R6
      jeq       DrawDigit4
      
      cmp.b     #3,R6
      jeq       DrawDigit3
      
      cmp.b     #2,R6
      jeq       DrawDigit2
      
      cmp.b     #1,R6
      jeq       DrawDigit1

      ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(The following subroutines DrawDigit1 - DrawDigit6) can be described using the following comment)
;Objectives: Draws digit or sign in R5 (0-13) at position N on the LCD (Where N represents the number at the end of DrawDigitN). 
;Preconditions: Value to draw must be on R5
;Postconditions: R5's value is drawn to N on the LCD. Nothing is changed
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawDigit1:
      MOV.B     #9,R11 ;Reuse R11 because why not
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit2:
      MOV.B     #5,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit3:
      MOV.B     #3,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit4:
      MOV.B     #2,R11
      MOV.B     DigitH(R5),0xA30(R11)
      MOV.B     DigitL(R5),0xA30+1(R11)
ret

DrawDigit5:
      MOV.B     #14,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret

DrawDigit6:
      MOV.B     #7,R11
      MOV.B     DigitH(R5),0xA20(R11)
      MOV.B     DigitL(R5),0xA20+1(R11)
ret
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;DRAWINT INTERNAL SUBROUTINES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;The following subroutines are meant to be *internal* and should not be used outside of DrawInt

;Objectives: Return call for values over 10000 or R6>7
;Preconditions: (none)
;Postconditions: Returns
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver10000:
      ret ;Return because we won't need to do that. ahahahaha

;Objectives: Handles the process of drawing an integer over 1000.
;Preconditions: Value to draw must be on R5 and must be at least over 1000. R11 must already be 0
;Postconditions: R5's Thousands place is drawn to the LCD at position R6. R5's thousands place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawIntOver100
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver1000:
      sub.w     #1000,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 1000 
      cmp       #1000,R5
      jge       DrawIntOver1000  ;until its no longer >=1000

     ;Draw and reset R11
      call      #DrawIntDrawR11
      
      inc.b     R6 ;Increment R6

      jmp       DrawIntOver100;Continue on to DrawIntOver100

;Objectives: Handles the process of drawing an integer over 100.
;Preconditions: Value to draw must be on R5. R11 must already be 0
;Postconditions: R5's Hundreds place is drawn to the LCD at position R6. R5's Hundreds place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawIntOver10
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver100:
      
      cmp       #100,R5
      jlo       DrawIntUnder100Already  ;Check if it's bellow 100. Otherwise, 
      
      sub.w     #100,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 100
      jmp       DrawIntOver100  ;until its no longer >=100
      
      ;Internal jump point to indicate we're already under 100.
      DrawIntUnder100Already:
      
      ;Draw and reset R11
      call      #DrawIntDrawR11
      inc.b     R6 ;Increment R6      

      jmp       DrawIntOver10 ;Continue on to DrawIntOver10

;Objectives: Handles the process of drawing an integer over 10.
;Preconditions: Value to draw must be on R5. R11 must already be 0
;Postconditions: R5's tens place is drawn to the LCD at position R6. R5's tens place is removed, and R6 is incremented. R11's value is returned to 0 when done. Hands off process to DrawDigit
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntOver10:
      cmp       #10,R5
      jlo       DrawIntUnder10Already  ;Check if we're already under 10. Otherwise...

      sub.w     #10,R5 ;Subtract and 
      inc.b     R11    ;keep track of how many times subtracted 1000 
      jmp       DrawIntOver10  ;until its no longer >=10

;Internal jump point to indicate we're already under 10
DrawIntUnder10Already:

      ;Draw and reset
      call      #DrawIntDrawR11
      inc.b     R6 ;Increment R6      
      
      ;Jump to DrawDigit. It has a return so we'll return once we draw the last digit
      jmp       DrawDigit


;Objectives: Handles the process of drawing a digit that's in R11 and clearing R11. INTERNAL USE ONLY FOR DrawIntOver(N) SUBROUTINES.
;Preconditions: Value to draw must be in R11 and must be between 0-9. Position to draw R11 must be on R6
;Postconditions: R11 is drawn to position R6, and is then set to 0. R5 is preserved.
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
DrawIntDrawR11:
      push.w    R5 ;Save R5
      mov.w     R11,R5 ;Move R11 to R5
      call      #DrawDigit ;Draw R11 (now in R5)
      pop.w     R5 ;Return R5
      mov.b     #0,R11 ;Reset R11 for the next subroutine.
      ret



;Objectives: Clears the LCD
;Preconditions: LCD is already initialized
;Postconditions: LCD is cleared
;Author: Ignacio Tampe (igtampe)
;Date: 3/7/2021
ClearLCD:
      MOV.W   #2,&LCDCMEMCTL
      BIS.W   #1,&LCDCCTL0
      ret
        
fin:    RET
        
TheEnd: JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        END
